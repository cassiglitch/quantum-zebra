<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird x Snake Game</title>
    <style>
        body {
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        canvas {
            position: fixed;
            top: 0;
            bottom: 0;
            border: 1px solid #ddd;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        #scoreDisplay {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 24px;
            font-family: Arial, sans-serif;
            color: #333;
        }
    </style>
</head>
<body>

<canvas id="snakeCanvas"></canvas>
<div id="scoreDisplay">Score: 0</div>

<script>
    const canvas = document.getElementById('snakeCanvas');
    const ctx = canvas.getContext('2d');
    let score = 0;
    let gravity = 2; // Gravity pulls the snake down
    let jumpStrength = 30; // Jump strength for upward movement
    let gridSize = 20;
    let food = { x: 0, y: 0 };
    let obstacles = [];
    let previousPositions = [];
    let isGameOver = false;
    
    const snake = [{ x: 100, y: 100 }]; // Snake starts with 1 segment
    let speed = 4;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Utility function to get a random grid position
    function getRandomGridPosition() {
        return {
            x: Math.floor(Math.random() * (canvas.width / gridSize)) * gridSize,
            y: Math.floor(Math.random() * (canvas.height / gridSize)) * gridSize,
        };
    }

    // Draw the snake
    function drawSnake() {
        ctx.fillStyle = "green";
        for (let segment of snake) {
            ctx.fillRect(segment.x, segment.y, gridSize, gridSize);
        }
    }

    // Draw food
    function drawFood() {
        ctx.fillStyle = "red";
        ctx.fillRect(food.x, food.y, gridSize, gridSize);
    }

    // Draw obstacles
    function drawObstacles() {
        ctx.fillStyle = "blue";
        for (let obstacle of obstacles) {
            ctx.fillRect(obstacle.x, obstacle.y, gridSize, gridSize);
        }
    }

    // Place food at a random position
    function placeFood() {
        food = getRandomGridPosition();
    }

    // Place obstacles randomly
    function placeObstacles() {
        for (let i = 0; i < 5; i++) {
            obstacles.push(getRandomGridPosition());
        }
    }

    // Detect collision with food
    function checkFoodCollision() {
        if (snake[0].x === food.x && snake[0].y === food.y) {
            score++;
            growSnake();
            placeFood();
        }
    }

    // Grow the snake
    function growSnake() {
        const lastSegment = snake[snake.length - 1];
        snake.push({ x: lastSegment.x, y: lastSegment.y });
        gravity ++
    }

    // Detect collision with obstacles
    function checkObstacleCollision() {
        for (let obstacle of obstacles) {
            if (snake[0].x === obstacle.x && snake[0].y === obstacle.y) {
                isGameOver = true;
                alert("Game Over! Your score: " + score);
                resetGame();
            }
        }
    }

    // Detect if snake's segments are overlapping
    function checkSnakeOverlap() {
        for (let i = 1; i < snake.length; i++) {
            if (snake[0].x === snake[i].x && snake[0].y === snake[i].y) {
                isGameOver = true;
                alert("Game Over! You collided with yourself. Score: " + score);
                resetGame();
            }
        }
    }

    // Reset the game
    function resetGame() {
        snake.length = 1;
        snake[0] = { x: 100, y: 100 };
        score = 0;
        placeFood();
        obstacles = [];
        placeObstacles();
        isGameOver = false;
    }

    // Update Snake function that ensures no overlap
    function updateSnake() {
        // Only update position if the snake moves horizontally or vertically
        let moved = false;

        // Apply gravity (falling down) to the head
        if (!isGameOver) {
            snake[0].y += gravity;
            moved = true;
        }

        // Move head left, right, or down
        document.addEventListener('keydown', (event) => {
            if (event.code === 'ArrowUp') {
                snake[0].y -= jumpStrength; // Jump upwards
                moved = true;
            } else if (event.code === 'ArrowLeft') {
                snake[0].x -= gridSize; // Move left
                moved = true;
            } else if (event.code === 'ArrowRight') {
                snake[0].x += gridSize; // Move right
                moved = true;
            } else if (event.code === 'ArrowDown') {
                snake[0].y += gridSize; // Move down
                moved = true;
            }
        });

        // Only record the position if the snake has moved
        if (moved) {
            // Store current position of the head
            previousPositions.unshift({ x: snake[0].x, y: snake[0].y });

            // Move the rest of the body segments based on previous positions
            for (let i = 1; i < snake.length; i++) {
                snake[i].x = previousPositions[i].x;
                snake[i].y = previousPositions[i].y;
            }

            // Limit the stored positions to match the length of the snake
            while (previousPositions.length > snake.length) {
                previousPositions.pop();
            }
        }
    }

    // Main game loop
    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

        updateSnake();
        checkFoodCollision();
        checkObstacleCollision();
        checkSnakeOverlap();

        drawSnake();
        drawFood();
        drawObstacles();

        document.getElementById('scoreDisplay').innerText = "Score: " + score;

        if (!isGameOver) {
            requestAnimationFrame(gameLoop);
        }
    }

    // Initial Setup
    placeFood();
    placeObstacles();
    gameLoop();
</script>

</body>
</html>
