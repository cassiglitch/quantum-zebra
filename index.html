<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Reality Destabilization</title>
<style>
    body {
        margin: 0;
        overflow: hidden;
    }
    canvas {
        display: block;
    }
</style>
</head>
<body>
<canvas id="crackCanvas"></canvas>
<script src="https://cdnjs.cloudflare.com/ajax/libs/delaunay/1.0.0/delaunay.min.js"></script>
<script>
const TWO_PI = Math.PI * 2;

let crackStrength = 1;
let cracks = [];

const canvas = document.getElementById('crackCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let clickPosition = [canvas.width * 0.5, canvas.height * 0.5];

function triangulate() {
    let rings = [
        { r: 50, c: 12 },
        { r: 150, c: 12 },
        { r: 300, c: 12 },
        { r: 1200, c: 12 } 
    ];

    let x, y;
    let centerX = clickPosition[0];
    let centerY = clickPosition[1];

    let vertices = [];
    vertices.push([centerX, centerY]);

    rings.forEach(function (ring) {
        let radius = ring.r;
        let count = ring.c;
        let variance = radius * 0.25;

        for (let i = 0; i < count; i++) {
            x = Math.cos((i / count) * TWO_PI) * radius + centerX + randomRange(-variance, variance);
            y = Math.sin((i / count) * TWO_PI) * radius + centerY + randomRange(-variance, variance);
            vertices.push([x, y]);
        }
    });

    vertices.forEach(function (v) {
        v[0] = clamp(v[0], 0, canvas.width);
        v[1] = clamp(v[1], 0, canvas.height);
    });

    let indices = Delaunay.triangulate(vertices);
    return indices;
}

function shatter() {
    let indices = triangulate();

    for (let i = 0; i < indices.length; i += 3) {
        let p0 = vertices[indices[i + 0]];
        let p1 = vertices[indices[i + 1]];
        let p2 = vertices[indices[i + 2]];

        cracks.push({
            x: p0[0],
            y: p0[1],
            length: Math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2),
            angle: Math.atan2(p1[1] - p0[1], p1[0] - p0[0])
        });

        cracks.push({
            x: p1[0],
            y: p1[1],
            length: Math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2),
            angle: Math.atan2(p2[1] - p1[1], p2[0] - p1[0])
        });

        cracks.push({
            x: p2[0],
            y: p2[1],
            length: Math.sqrt((p2[0] - p0[0]) ** 2 + (p2[1] - p0[1]) ** 2),
            angle: Math.atan2(p0[1] - p2[1], p0[0] - p2[0])
        });
    }
}

function animate() {
    requestAnimationFrame(animate);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    crackStrength += 0.01;
    if (crackStrength >= 1) {
        shatter();
        crackStrength = 0;
    }

    cracks.forEach(crack => {
        ctx.beginPath();
        ctx.moveTo(crack.x, crack.y);
        ctx.lineTo(crack.x + Math.cos(crack.angle) * crack.length, crack.y + Math.sin(crack.angle) * crack.length);
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 3;
        ctx.stroke();
    });
}

animate();

// Helper functions
function randomRange(min, max) {
    return min + Math.random() * (max - min);
}

function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
</script>
</body>
</html>
